/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "libpq-fe.h"
#include "im.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <time.h>
#include <assert.h>

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

void *threadTask(void *arg)
{
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
    const char *paramValues[1];
	while (1)
	{
		conn = PQconnectdb(conninfo);

		if (PQstatus(conn) != CONNECTION_OK)
		{
		    exit_nicely(conn);
			printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
			return NULL;
		}
		
		time_t current_time = time(NULL);
		struct tm * time_info;
		time_info = localtime(&current_time);
		char * buffer = malloc(sizeof(char)*80);
		time_info->tm_min -= 10; 
		strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", time_info);
		
		paramValues[0] = buffer;
		res = PQexecParams(conn, "SELECT * FROM users WHERE last_action < $1 AND onlinestatus = true", 1, NULL, paramValues, NULL, NULL, 0);
		if (PQresultStatus(res) != PGRES_TUPLES_OK)
		{
		    PQclear(res);
		    exit_nicely(conn);
			printf ("Cannot get data from db: %s\n", PQerrorMessage(conn));
			return NULL;
		}
	
		if(PQntuples(res) > 0)
		{
			int i;
			for (i = 0; i < PQntuples(res); ++i)
			{
				PGresult *res_upd;
				paramValues[0] = PQgetvalue(res, i, 0);
				res_upd = PQexecParams(conn, "UPDATE users SET onlinestatus = false WHERE id=$1", 1, NULL, paramValues, NULL, NULL, 0);
				if (PQresultStatus(res_upd) != PGRES_COMMAND_OK)
				{
					fprintf(stderr, "Error update users: %s", PQerrorMessage(conn));
					PQclear(res_upd);
					exit_nicely(conn);
				}
				PQclear(res_upd);
				res_upd = PQexecParams(conn, "DELETE FROM sessions WHERE id = $1", 1, NULL, paramValues, NULL, NULL, 0);
				if (PQresultStatus(res_upd) != PGRES_COMMAND_OK)
				{
					printf ("Cannot remove old sessions, for user: %s \n", PQerrorMessage(conn));
					PQclear(res_upd);
					exit_nicely(conn);
				}
				PQclear(res_upd);
			}
		}
	
		PQclear(res);

		PQfinish(conn);
		sleep(60);
	}
	return NULL;
}

static void
im_messenger_3(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		Args_login login_3_arg;
		Session getuserroster_3_arg;
		Session getmessageshistory_3_arg;
		Session getunreadmessages_3_arg;
		Args_sendMessage sendmessage_3_arg;
		Args_addUserToRoster addusertoroster_3_arg;
		Args_deleteUserFromRoster deleteuserfromroster_3_arg;
		Args_findUser finduser_3_arg;
		Session getfriendshiprequests_3_arg;
		Args_register signup_3_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case login:
		_xdr_argument = (xdrproc_t) xdr_Args_login;
		_xdr_result = (xdrproc_t) xdr_Result_login;
		local = (char *(*)(char *, struct svc_req *)) login_3_svc;
		break;

	case getUserRoster:
		_xdr_argument = (xdrproc_t) xdr_Session;
		_xdr_result = (xdrproc_t) xdr_Result_getUserRoster;
		local = (char *(*)(char *, struct svc_req *)) getuserroster_3_svc;
		break;

	case getMessagesHistory:
		_xdr_argument = (xdrproc_t) xdr_Session;
		_xdr_result = (xdrproc_t) xdr_Result_getMessagesHistory;
		local = (char *(*)(char *, struct svc_req *)) getmessageshistory_3_svc;
		break;

	case getUnreadMessages:
		_xdr_argument = (xdrproc_t) xdr_Session;
		_xdr_result = (xdrproc_t) xdr_Result_getUnreadMessages;
		local = (char *(*)(char *, struct svc_req *)) getunreadmessages_3_svc;
		break;

	case sendMessage:
		_xdr_argument = (xdrproc_t) xdr_Args_sendMessage;
		_xdr_result = (xdrproc_t) xdr_Status;
		local = (char *(*)(char *, struct svc_req *)) sendmessage_3_svc;
		break;

	case addUserToRoster:
		_xdr_argument = (xdrproc_t) xdr_Args_addUserToRoster;
		_xdr_result = (xdrproc_t) xdr_Status;
		local = (char *(*)(char *, struct svc_req *)) addusertoroster_3_svc;
		break;

	case deleteUserFromRoster:
		_xdr_argument = (xdrproc_t) xdr_Args_deleteUserFromRoster;
		_xdr_result = (xdrproc_t) xdr_Status;
		local = (char *(*)(char *, struct svc_req *)) deleteuserfromroster_3_svc;
		break;

	case findUser:
		_xdr_argument = (xdrproc_t) xdr_Args_findUser;
		_xdr_result = (xdrproc_t) xdr_Result_findUser;
		local = (char *(*)(char *, struct svc_req *)) finduser_3_svc;
		break;

	case getFriendshipRequests:
		_xdr_argument = (xdrproc_t) xdr_Session;
		_xdr_result = (xdrproc_t) xdr_Result_getFriendshipRequests;
		local = (char *(*)(char *, struct svc_req *)) getfriendshiprequests_3_svc;
		break;

	case signup:
		_xdr_argument = (xdrproc_t) xdr_Args_register;
		_xdr_result = (xdrproc_t) xdr_Status;
		local = (char *(*)(char *, struct svc_req *)) signup_3_svc;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

void clearSession()
{
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
	
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
		printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
    }
    res = PQexecParams(conn, "DELETE FROM sessions", 0, NULL, NULL, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
		printf ("Cannot remove old sessions: %s\n", PQerrorMessage(conn));
		PQclear(res);
        exit_nicely(conn);
    }
	
    PQclear(res);
	PQfinish(conn);
}

int
main (int argc, char **argv)
{
	clearSession();
	
	register SVCXPRT *transp;
	
	pthread_t thread;
	int rc = pthread_create(&thread, NULL, threadTask, (void *) NULL);
	assert(rc == 0);
	
	pmap_unset (IM_MESSENGER, VER);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, IM_MESSENGER, VER, im_messenger_3, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (IM_MESSENGER, VER, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, IM_MESSENGER, VER, im_messenger_3, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (IM_MESSENGER, VER, tcp).");
		exit(1);
	}

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}
