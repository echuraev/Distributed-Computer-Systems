/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "libpq-fe.h"
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "im.h"

#define true 1
#define false 0

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
}

char * itoa(int num)
{
	char * buff = malloc(sizeof(char) * 10);
    snprintf(buff, 10,"%d",num);
	return buff;	
}

int getUserId(int sessionId)
{
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
    const char * paramVal[1];
    
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
        exit_nicely(conn);
        printf("\nCONNECT PROBLEM\n");
        return -1;
    }

    paramVal[0] = itoa(sessionId);
    res = PQexecParams(conn, "SELECT user_id FROM sessions WHERE id = $1", 1, NULL, paramVal, NULL, NULL, 0);
	if (PQresultStatus(res) != PGRES_TUPLES_OK)
	{
		PQclear(res);
		exit_nicely(conn);
		printf("\nGET DATA PROBLEM\n");
		return -1;
	}
	if(PQntuples(res) == 0)
	{
		PQclear(res);
		exit_nicely(conn);
		printf("\nEMPTY RESULTS PROBLEM\n");
		return -1;
	}
	int id = atoi(PQgetvalue(res, 0, 0));
	PQclear(res);
	PQfinish(conn);
	return id;
}

int updateActionTime(int userId)
{	
	const char *conninfo;
    PGconn     *conn;
    conninfo = "dbname=echuraev";
    const char * paramVal[2];
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
        exit_nicely(conn);
        return false;
    }
    paramVal[0] = itoa(userId);
    
    PGresult *res_upd;
	time_t current_time = time(NULL);
	struct tm * time_info;
	time_info = localtime(&current_time);
	char * buffer = malloc(sizeof(char)*80);
	strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", time_info);
	paramVal[1] = buffer;
	res_upd = PQexecParams(conn, "UPDATE users SET onlinestatus = true, last_action = $2 WHERE id=$1", 2, NULL, paramVal, NULL, NULL, 0);
	if (PQresultStatus(res_upd) != PGRES_COMMAND_OK)
	{
		PQclear(res_upd);
		exit_nicely(conn);
		return false;
	}
	PQclear(res_upd);

	PQfinish(conn);
	return true;
}

Result_login *
login_3_svc(Args_login *argp, struct svc_req *rqstp)
{
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
    const char *paramValues[2];
    static Result_login  result;

    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.user.name = "";
		result.user.nick = "";
        return &result;
    }
    
    paramValues[0] = argp->name;
    paramValues[1] = argp->passwd;
    res = PQexecParams(conn, "SELECT * FROM users WHERE nick = $1 AND passwd = $2", 2, NULL, paramValues, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        PQclear(res);
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Cannot get data from db:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.user.name = "";
		result.user.nick = "";
        return &result;
    }
	
	if(PQntuples(res) == 0)
	{
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Error! Cannot find ");
		strcat(errmsg, argp->name);
		strcat(errmsg, " in bd!");
		result.status.descr = errmsg;
		result.status.stat = false;
		result.user.name = "";
		result.user.nick = "";
	}
	else
	{
		const char *paramVal[1];
		result.status.stat = true;
		result.status.descr = "";
		result.user.id = atoi(PQgetvalue(res, 0, 0));
		result.user.name = PQgetvalue(res, 0, 1);
		result.user.nick = PQgetvalue(res, 0, 2);
		result.user.onlineStatus = true;
		result.user.isFriend = false;
		
		paramVal[0] = PQgetvalue(res, 0, 0);
		PGresult * resSes = PQexecParams(conn, "SELECT id FROM sessions WHERE user_id = $1", 1, NULL, paramVal, NULL, NULL, 0);
		if (PQresultStatus(resSes) != PGRES_TUPLES_OK)
		{
			PQclear(resSes);
			exit_nicely(conn);
			char* errmsg = malloc(sizeof(char)*500); 
			strcpy(errmsg, "Cannot get data from session:\n");
			strcat(errmsg, PQerrorMessage(conn));
			result.status.descr = errmsg;
			result.status.stat = false;
			return &result;
		}
		if(PQntuples(resSes) > 0)
		{
			result.session.id = atoi(PQgetvalue(resSes, 0, 0));
			return &result;
		}
		resSes = PQexecParams(conn, "INSERT INTO sessions (user_id) values($1)", 1, NULL, paramVal, NULL, NULL, 0);
		if (PQresultStatus(resSes) != PGRES_COMMAND_OK)
		{
		    PQclear(resSes);
		    exit_nicely(conn);
		    char* errmsg = malloc(sizeof(char)*500); 
			strcpy(errmsg, "Cannot add info to sessions:\n");
			strcat(errmsg, PQerrorMessage(conn));
			result.status.descr = errmsg;
			result.status.stat = false;
			return &result;
		}
		else
		{
			PQclear(resSes);
			resSes = PQexecParams(conn, "SELECT id FROM sessions WHERE user_id = $1", 1, NULL, paramVal, NULL, NULL, 0);
			if (PQresultStatus(resSes) != PGRES_TUPLES_OK)
			{
				PQclear(resSes);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				strcpy(errmsg, "Cannot get data from session:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				return &result;
			}
			if(PQntuples(resSes) == 0)
			{
				PQclear(resSes);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				strcpy(errmsg, "Cannot find session!");
				result.status.descr = errmsg;
				result.status.stat = false;
				return &result;
			}
			else
			{
				result.session.id = atoi(PQgetvalue(resSes, 0, 0));
			}
			PQclear(resSes);
		}
		printf("session id = %d\n", result.session.id);
		
		if (!updateActionTime(result.user.id))
		{
			result.status.descr = "Error! Cannot update action time!";
			result.status.stat = false;
		}
	}
	
    PQclear(res);

	PQfinish(conn);    
	printf("login_3_svc() called\n");

	return &result;
}

Result_getUserRoster *
getuserroster_3_svc(Session *argp, struct svc_req *rqstp)
{
	static Result_getUserRoster  result;
	result.status.descr = "";
	result.status.stat = true;
	result.roster.roster_val = NULL;
	result.roster.roster_len = 0;
	int userId = getUserId(argp->id);
	if (userId < 0)
	{
		printf("Error! Cannot get user id!\n");
		result.status.descr = "Error! Cannot get user id!";
		result.status.stat = false;
		result.roster.roster_val = NULL;
		return &result;
	}
	if (!updateActionTime(userId))
	{
		result.status.descr = "Error! Cannot update action time!";
		printf("Error! Cannot update action time!\n");
		result.status.stat = false;
		result.roster.roster_val = NULL;
		return &result;
	}
	
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
	const char * paramValues [1];
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
		printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.roster.roster_val = NULL;
        return &result;
    }
	
	paramValues[0] = itoa(userId);
	res = PQexecParams(conn, "SELECT roster_user, tustatus FROM roster WHERE tustatus > -1 AND target_user = $1", 1, NULL, paramValues, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        PQclear(res);
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
        printf("Cannot get data from db for roster list: %s\n", PQerrorMessage(conn));
		strcpy(errmsg, "Cannot get data from db for roster list:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.roster.roster_val = NULL;
        return &result;
    }
	if(PQntuples(res) == 0)
	{
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "");
		result.status.descr = errmsg;
		result.status.stat = true;
		result.roster.roster_val = NULL;
	}
	else
	{
		result.status.descr = "";
		result.status.stat = true;
		User * u = malloc(sizeof(User) * PQntuples(res));
		int i;
		for (i = 0; i < PQntuples(res); ++i)
		{
			printf("user id: %s\n", PQgetvalue(res, i, 0));
			paramValues[0] = PQgetvalue(res, i, 0);
			PGresult * res_upd = PQexecParams(conn, "SELECT * FROM users WHERE id = $1", 1, NULL, paramValues, NULL, NULL, 0);
			if (PQresultStatus(res_upd) != PGRES_TUPLES_OK)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Cannot get data from db for roster list item: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Cannot get data from db for roster list item:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				result.roster.roster_val = NULL;
				return &result;
			}
			if(PQntuples(res_upd) == 0)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				strcpy(errmsg, "Cannot find user to roster list!");
				result.status.descr = errmsg;
				result.status.stat = false;
				result.roster.roster_val = NULL;
				return &result;
			}
			else
			{
				u[i].id = atoi(PQgetvalue(res_upd, 0, 0));
				char * var = PQgetvalue(res_upd, 0, 1);
				u[i].name = malloc(strlen(var)*sizeof(char)+1);
				strcpy(u[i].name, var);
				
				u[i].nick = PQgetvalue(res_upd, 0, 2);
				if (!strcmp(PQgetvalue(res_upd, 0, 4), "t"))
					u[i].onlineStatus = true;
				else
					u[i].onlineStatus = false;	
				int friendStatus = atoi(PQgetvalue(res, i, 1));
				if (friendStatus > 0)
					u[i].isFriend = true;
				else
					u[i].isFriend = false;
			}
			PQclear(res_upd);
			printf("%d\t%s\t%d\n", u[i].id, u[i].nick, u[i].isFriend);
		}
		result.roster.roster_len = PQntuples(res);
		result.roster.roster_val = u;
		printf("FINAL CHECK START\n");
		for (i = 0; i < result.roster.roster_len; ++i)
		{printf("%d\t%s\n", u[i].id, u[i].nick);}
		printf("FINAL CHECK END\n");
	}
	
	PQclear(res);

	PQfinish(conn);
	printf("getuserroster_3_svc called\n");
	return &result;
}

Result_getMessagesHistory *
getmessageshistory_3_svc(Session *argp, struct svc_req *rqstp)
{
	static Result_getMessagesHistory  result;
	result.status.descr = "";
	result.status.stat = true;
	result.messages.messages_val = NULL;
	result.messages.messages_len = 0;
	int userId = getUserId(argp->id);
	if (userId < 0)
	{
		printf("Error! Cannot get user id!\n");
		result.status.descr = "Error! Cannot get user id!";
		result.status.stat = false;
		result.messages.messages_val = NULL;
		return &result;
	}
	if (!updateActionTime(userId))
	{
		result.status.descr = "Error! Cannot update action time!";
		printf("Error! Cannot update action time!\n");
		result.status.stat = false;
		result.messages.messages_val = NULL;
		return &result;
	}
	
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
	const char * paramValues [1];
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
		printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.messages.messages_val = NULL;
        return &result;
    }
	
	paramValues[0] = itoa(userId);
	res = PQexecParams(conn, "SELECT * FROM messages WHERE recipient = $1 or sender = $1 ORDER BY dtime", 1, NULL, paramValues, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        PQclear(res);
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
        printf("Cannot get data from db for messages: %s\n", PQerrorMessage(conn));
		strcpy(errmsg, "Cannot get data from db for messages:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.messages.messages_val = NULL;
        return &result;
    }
    printf("count: %d\n", PQntuples(res));
	if(PQntuples(res) == 0)
	{
		printf("NO Messages\n");
		result.status.descr = "";
		result.status.stat = true;
		result.messages.messages_val = NULL;
	}
	else
	{
		result.status.descr = "";
		result.status.stat = true;
		Message * m = malloc(sizeof(Message) * PQntuples(res));
		int i;
		for (i = 0; i < PQntuples(res); ++i)
		{			
			paramValues[0] = PQgetvalue(res, i, 0);
			PGresult * res_upd = PQexecParams(conn, "UPDATE messages SET msg_read = TRUE WHERE id=$1", 1, NULL, paramValues, NULL, NULL, 0);
			if (PQresultStatus(res_upd) != PGRES_COMMAND_OK)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				strcpy(errmsg, "Cannot update message:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			PQclear(res_upd);
			
			/* sender user start */
			paramValues[0] = PQgetvalue(res, i, 1);
			res_upd = PQexecParams(conn, "SELECT * FROM users WHERE id=$1", 1, NULL, paramValues, NULL, NULL, 0);
			if (PQresultStatus(res_upd) != PGRES_TUPLES_OK)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Cannot get data from db for message: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Cannot get data from db for message:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			if(PQntuples(res_upd) == 0)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Not found sender for message: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Not found sender for message.");
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			else
			{
				m[i].sender.id = atoi(PQgetvalue(res_upd, 0, 0));
				m[i].sender.name = PQgetvalue(res_upd, 0, 1);
				m[i].sender.nick = PQgetvalue(res_upd, 0, 2);
				printf("sender %d:%s\n", m[i].sender.id, m[i].sender.nick);
				if (!strcmp(PQgetvalue(res_upd, 0, 4), "true"))
					m[i].sender.onlineStatus = true;
				else
					m[i].sender.onlineStatus = false;
				m[i].sender.isFriend = true;
			}
			PQclear(res_upd);
			/* sender user end */
			
			/* recipient user start */
			paramValues[0] = PQgetvalue(res, i, 2);
			res_upd = PQexecParams(conn, "SELECT * FROM users WHERE id=$1", 1, NULL, paramValues, NULL, NULL, 0);
			if (PQresultStatus(res_upd) != PGRES_TUPLES_OK)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Cannot get data from db for message: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Cannot get data from db for message:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			if(PQntuples(res_upd) == 0)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Not found recipient for message: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Not found recipient for message.");
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			else
			{
				m[i].recipient.id = atoi(PQgetvalue(res_upd, 0, 0));
				m[i].recipient.name = PQgetvalue(res_upd, 0, 1);
				m[i].recipient.nick = PQgetvalue(res_upd, 0, 2);
				if (!strcmp(PQgetvalue(res_upd, 0, 4), "true"))
					m[i].recipient.onlineStatus = true;
				else
					m[i].recipient.onlineStatus = false;
				m[i].recipient.isFriend = true;
				printf("recipient %d:%s\n", m[i].recipient.id, m[i].recipient.nick);
			}
			PQclear(res_upd);
			/* recipient user end */
			m[i].msg = PQgetvalue(res, i, 3);
			m[i].read = true;
			const char *time_details = PQgetvalue(res, i, 5);
			struct tm tm;
			strptime(time_details, "%Y-%m-%d %H:%M:%S", &tm);
			time_t t = mktime(&tm);
			m[i].date = (unsigned int) t;
			printf("\r\n%d, %s -> %d, %s\t%s\n", m[i].sender.id, m[i].sender.nick, m[i].recipient.id, m[i].recipient.nick, m[i].msg);
		}
		result.messages.messages_val = m;
		result.messages.messages_len = PQntuples(res);
	}
	
	PQclear(res);

	PQfinish(conn);
	
	printf("getmessageshistory_3_svc called\n");

	return &result;
}

Result_getUnreadMessages *
getunreadmessages_3_svc(Session *argp, struct svc_req *rqstp)
{
	static Result_getUnreadMessages  result;
	result.status.descr = "";
	result.status.stat = false;
	result.messages.messages_val = NULL;
	result.messages.messages_len = 0;
	int userId = getUserId(argp->id);
	if (userId < 0)
	{
		printf("Error! Cannot get user id!\n");
		result.status.descr = "Error! Cannot get user id!";
		result.status.stat = false;
		result.messages.messages_val = NULL;
		return &result;
	}
	if (!updateActionTime(userId))
	{
		result.status.descr = "Error! Cannot update action time!";
		printf("Error! Cannot update action time!\n");
		result.status.stat = false;
		result.messages.messages_val = NULL;
		return &result;
	}
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
	const char * paramValues [1];
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
		printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.messages.messages_val = NULL;
        return &result;
    }
	
	paramValues[0] = itoa(userId);
	res = PQexecParams(conn, "SELECT * FROM messages WHERE msg_read = FALSE AND recipient = $1", 1, NULL, paramValues, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        PQclear(res);
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
        printf("Cannot get data from db for unread messegas: %s\n", PQerrorMessage(conn));
		strcpy(errmsg, "Cannot get data from db for unread messages:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.messages.messages_val = NULL;
        return &result;
    }
    printf("count: %d\n", PQntuples(res));
	if(PQntuples(res) == 0)
	{
		printf("NO UNREAD\n");
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "No unread messages.");
		result.status.descr = errmsg;
		result.status.stat = true;
		result.messages.messages_val = NULL;
	}
	else
	{
		printf("YES to read!\n");
		result.status.descr = "";
		result.status.stat = true;
		Message * m = malloc(sizeof(Message) * PQntuples(res));
		int i;
		for (i = 0; i < PQntuples(res); ++i)
		{
			const char * paramVal[1];
			paramVal[0] = PQgetvalue(res, i, 0);
			PGresult * res_upd;/* = PQexecParams(conn, "UPDATE messages SET msg_read = TRUE WHERE id=$1", 1, NULL, paramVal, NULL, NULL, 0);
			if (PQresultStatus(res_upd) != PGRES_COMMAND_OK)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Cannot update unread message:%s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Cannot update unread message:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			PQclear(res_upd);*/
			
			/* sender user start */
			paramVal[0] = PQgetvalue(res, i, 1);
			res_upd = PQexecParams(conn, "SELECT * FROM users WHERE id=$1", 1, NULL, paramVal, NULL, NULL, 0);
			if (PQresultStatus(res_upd) != PGRES_TUPLES_OK)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Cannot get data from db for unread message: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Cannot get data from db for unread message:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			if(PQntuples(res_upd) == 0)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Not found sender for unread message: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Not found sender for unread message for unread message.");
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			else
			{
				m[i].sender.id = atoi(PQgetvalue(res_upd, 0, 0));
				char * name = malloc(sizeof(char) * strlen(PQgetvalue(res_upd, 0, 1)));
				strcpy(name, PQgetvalue(res_upd, 0, 1));
				m[i].sender.name = name;
				char * nick = malloc(sizeof(char) * strlen(PQgetvalue(res_upd, 0, 2)));
				strcpy(nick, PQgetvalue(res_upd, 0, 2));
				m[i].sender.nick = nick;
				printf("sender %d:%s\n", m[i].sender.id, m[i].sender.nick);
				if (!strcmp(PQgetvalue(res_upd, 0, 4), "true"))
					m[i].sender.onlineStatus = true;
				else
					m[i].sender.onlineStatus = false;
				m[i].sender.isFriend = true;
			}
			PQclear(res_upd);
			/* sender user end */
			
			/* recipient user start */
			paramVal[0] = itoa(userId);
			res_upd = PQexecParams(conn, "SELECT * FROM users WHERE id=$1", 1, NULL, paramVal, NULL, NULL, 0);
			if (PQresultStatus(res_upd) != PGRES_TUPLES_OK)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Cannot get data from db for unread message: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Cannot get data from db for unread message:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			if(PQntuples(res_upd) == 0)
			{
				PQclear(res_upd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Not found recipient for unread message: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Not found recipient for unread message for unread message.");
				result.status.descr = errmsg;
				result.status.stat = false;
				result.messages.messages_val = NULL;
				return &result;
			}
			else
			{
				m[i].recipient.id = userId;
				m[i].recipient.name = PQgetvalue(res_upd, 0, 1);
				m[i].recipient.nick = PQgetvalue(res_upd, 0, 2);
				m[i].recipient.onlineStatus = true;
				m[i].recipient.isFriend = false;
				printf("recipient %d:%s\n", m[i].recipient.id, m[i].recipient.nick);
			}
			PQclear(res_upd);
			/* recipient user end */
			m[i].msg = PQgetvalue(res, i, 3);
			m[i].read = true;
			const char *time_details = PQgetvalue(res, i, 5);
			struct tm tm;
			strptime(time_details, "%Y-%m-%d %H:%M:%S", &tm);
			time_t t = mktime(&tm);
			m[i].date = (unsigned int) t;
			printf("\n%d, %s -> %d, %s\t%s\n", m[i].sender.id, m[i].sender.nick, m[i].recipient.id, m[i].recipient.nick, m[i].msg);
		}
		result.messages.messages_len = PQntuples(res);
		result.messages.messages_val = m;
	}
	
	PQclear(res);

	PQfinish(conn);
	printf("getunreadmessages_3_svc called\n");
	return &result;
}

Status *
sendmessage_3_svc(Args_sendMessage *argp, struct svc_req *rqstp)
{
	static Status  result;
	result.descr = "";
	result.stat = true;
			
	int userId = getUserId(argp->session.id);
	if (userId < 0)
	{
		printf("Error! Cannot get user id!\n");
		result.descr = "Error! Cannot get user id!";
		result.stat = false;
		return &result;
	}
	if (!updateActionTime(userId))
	{
		result.descr = "Error! Cannot update action time!";
		printf("Error! Cannot update action time!\n");
		result.stat = false;
		return &result;
	}
	
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
	const char * paramValues [4];
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
		printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
        return &result;
    }
	
	time_t current_time = time(NULL);
	struct tm * time_info;
	time_info = localtime(&current_time);
	char * buffer = malloc(sizeof(char)*80);
	strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", time_info);
	paramValues[0] = itoa(userId);
	paramValues[1] = itoa(argp->recipientId);
	paramValues[2] = argp->msg;
	paramValues[3] = buffer;
	res = PQexecParams(conn, "INSERT INTO messages (sender, recipient, message, msg_read, dtime) values($1, $2, $3, false, $4)", 4, NULL, paramValues, NULL, NULL, 0);
	if (PQresultStatus(res) != PGRES_COMMAND_OK)
	{
		printf ("Cannot send message: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Cannot send message:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
        return &result;
	}
	PQclear(res);
	
	PQfinish(conn);
	
	printf("sendmessage_3_svc called\n");
	return &result;
}

Status *
addusertoroster_3_svc(Args_addUserToRoster *argp, struct svc_req *rqstp)
{
	static Status  result;
	result.descr = "";
	result.stat = true;
			
	int userId = getUserId(argp->session.id);
	if (userId < 0)
	{
		printf("Error! Cannot get user id!\n");
		result.descr = "Error! Cannot get user id!";
		result.stat = false;
		return &result;
	}
	if (!updateActionTime(userId))
	{
		result.descr = "Error! Cannot update action time!";
		printf("Error! Cannot update action time!\n");
		result.stat = false;
		return &result;
	}
	
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
	const char * paramValues [2];
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
		printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
        return &result;
    }
	
	paramValues[0] = itoa(userId);
	paramValues[1] = itoa(argp->userId);
	res = PQexecParams(conn, "SELECT id, tustatus, rustatus FROM roster WHERE target_user = $2 AND roster_user = $1", 2, NULL, paramValues, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        PQclear(res);
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
        printf("Cannot get data from db for add to roster: %s\n", PQerrorMessage(conn));
		strcpy(errmsg, "Cannot get data from db for add to roster:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
        return &result;
    }
	if(PQntuples(res) == 0)
	{
		// Send request
		PGresult * res_upd = PQexecParams(conn, "INSERT INTO roster (target_user, roster_user, tustatus, rustatus) values($1, $2, 0, 0)", 2, NULL, paramValues, NULL, NULL, 0);
		if (PQresultStatus(res_upd) != PGRES_COMMAND_OK)
		{
		    PQclear(res_upd);
		    exit_nicely(conn);
		    char* errmsg = malloc(sizeof(char)*500); 
			strcpy(errmsg, "Cannot add info to db:\n");
			strcat(errmsg, PQerrorMessage(conn));
			result.descr = errmsg;
			result.stat = false;
		}
		PQclear(res_upd);
	}
	else
	{
		// Access on request
		const char * paramVal[1];
		paramVal[0] = PQgetvalue(res, 0, 0);
		PGresult * res_upd = PQexecParams(conn, "UPDATE roster SET tustatus = 1, rustatus = 1 WHERE id=$1", 1, NULL, paramVal, NULL, NULL, 0);
		if (PQresultStatus(res_upd) != PGRES_COMMAND_OK)
		{
			PQclear(res_upd);
			exit_nicely(conn);
			char* errmsg = malloc(sizeof(char)*500); 
			strcpy(errmsg, "Cannot update info into roster:\n");
			strcat(errmsg, PQerrorMessage(conn));
			result.descr = errmsg;
			result.stat = false;
			return &result;
		}
		PQclear(res_upd);
		
		res_upd = PQexecParams(conn, "SELECT id FROM roster WHERE target_user = $1 AND roster_user = $2", 2, NULL, paramValues, NULL, NULL, 0);
		if (PQresultStatus(res_upd) != PGRES_TUPLES_OK)
		{
		    PQclear(res_upd);
		    exit_nicely(conn);
		    char* errmsg = malloc(sizeof(char)*500); 
		    printf("Cannot get data from db for add to roster for update: %s\n", PQerrorMessage(conn));
			strcpy(errmsg, "Cannot get data from db for add to roster for update:\n");
			strcat(errmsg, PQerrorMessage(conn));
			result.descr = errmsg;
			result.stat = false;
		    return &result;
		}
		if(PQntuples(res_upd) == 0)
		{
			PGresult * resIns = PQexecParams(conn, "INSERT INTO roster (target_user, roster_user, tustatus, rustatus) values($1, $2, 1, 1)", 2, NULL, paramValues, NULL, NULL, 0);
			if (PQresultStatus(resIns) != PGRES_COMMAND_OK)
			{
				PQclear(resIns);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				strcpy(errmsg, "Cannot add info to db:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.descr = errmsg;
				result.stat = false;
			}
			PQclear(resIns);
		}
		else
		{
			paramVal[0] = PQgetvalue(res_upd, 0, 0);
			PGresult * resUpd = PQexecParams(conn, "UPDATE roster SET tustatus = 1, rustatus = 1 WHERE id=$1", 1, NULL, paramVal, NULL, NULL, 0);
			if (PQresultStatus(resUpd) != PGRES_COMMAND_OK)
			{
				PQclear(resUpd);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				strcpy(errmsg, "Cannot update info into roster:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.descr = errmsg;
				result.stat = false;
				return &result;
			}
			PQclear(resUpd);
		}
		PQclear(res_upd);
	}
	
	PQclear(res);

	PQfinish(conn); 
	printf("addusertoroster_3_svc called\n");
	return &result;
}

Status *
deleteuserfromroster_3_svc(Args_deleteUserFromRoster *argp, struct svc_req *rqstp)
{
	static Status  result;
	result.descr = "";
	result.stat = true;
			
	int userId = getUserId(argp->session.id);
	if (userId < 0)
	{
		printf("Error! Cannot get user id!\n");
		result.descr = "Error! Cannot get user id!";
		result.stat = false;
		return &result;
	}
	if (!updateActionTime(userId))
	{
		result.descr = "Error! Cannot update action time!";
		printf("Error! Cannot update action time!\n");
		result.stat = false;
		return &result;
	}
	
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
	const char * paramValues [2];
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
		printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
        return &result;
    }
	
	paramValues[0] = itoa(userId);
	paramValues[1] = itoa(argp->userId);
	res = PQexecParams(conn, "UPDATE roster SET tustatus = -1, rustatus = 0 WHERE target_user = $1 AND roster_user = $2", 2, NULL, paramValues, NULL, NULL, 0);
	if (PQresultStatus(res) != PGRES_COMMAND_OK)
	{
		printf ("Cannot set status -1: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Cannot set status -1:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
        return &result;
	}
	PQclear(res);
	res = PQexecParams(conn, "UPDATE roster SET tustatus = 0, rustatus = -1 WHERE target_user = $2 AND roster_user = $1", 2, NULL, paramValues, NULL, NULL, 0);
	if (PQresultStatus(res) != PGRES_COMMAND_OK)
	{
		printf ("Cannot set status 0: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Cannot set status 0:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
        return &result;
	}
	PQclear(res);
	PQfinish(conn);
	printf("deleteuserfromroster_3_svc called\n");
	return &result;
}

Result_findUser *
finduser_3_svc(Args_findUser *argp, struct svc_req *rqstp)
{
	static Result_findUser  result;
	result.status.descr = "";
	result.status.stat = true;
	result.users.users_val = NULL;
	result.users.users_len = 0;
	char * findStr;
	if (strlen(argp->name) > 0)
		findStr = argp->name;
	else
		findStr = argp->nick;
	
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
	const char * paramValues [2];
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
		printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.users.users_val = NULL;
        return &result;
    }
	
	int userId = getUserId(argp->session.id);
	if (userId < 0)
	{
		printf("Error! Cannot get user id!\n");
		result.status.descr = "Error! Cannot get user id!";
		result.status.stat = false;
		result.users.users_val = NULL;
		return &result;
	}
	if (!updateActionTime(userId))
	{
		result.status.descr = "Error! Cannot update action time!";
		printf("Error! Cannot update action time!\n");
		result.status.stat = false;
		result.users.users_val = NULL;
		return &result;
	}
	paramValues[0] = findStr;
	paramValues[1] = itoa(userId);
    res = PQexecParams(conn, "SELECT * FROM users WHERE (nick = $1 OR name = $1) AND id != $2", 2, NULL, paramValues, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        PQclear(res);
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
        printf("Cannot get data from db for find: %s\n", PQerrorMessage(conn));
		strcpy(errmsg, "Cannot get data from db for find:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.users.users_val = NULL;
        return &result;
    }
	if(PQntuples(res) == 0)
	{
		printf("Cannot find data from db for find: %s\n", PQerrorMessage(conn));
		result.status.descr = "";
		result.status.stat = true;
		result.users.users_val = NULL;
	}
	else
	{
		result.status.descr = "";
		result.status.stat = true;
		User * u = malloc(sizeof(User)*PQntuples(res));
		int i;
		for (i = 0; i < PQntuples(res); ++i)
		{
			u[i].id = atoi(PQgetvalue(res, i, 0));
			u[i].name = PQgetvalue(res, i, 1);
			u[i].nick = PQgetvalue(res, i, 2);
			if (!strcmp(PQgetvalue(res, i, 4), "t"))
				u[i].onlineStatus = true;
			else
				u[i].onlineStatus = false;
			paramValues[0] = itoa(userId);	
			paramValues[1] = PQgetvalue(res, i, 0);
			PGresult* resFr = PQexecParams(conn, "SELECT tustatus FROM roster WHERE target_user = $1 AND roster_user = $2", 2, NULL, paramValues, NULL, NULL, 0);
			if (PQresultStatus(resFr) != PGRES_TUPLES_OK)
			{
				PQclear(resFr);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Cannot get friendship status from db: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Cannot get friendship status from db:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				result.users.users_val = NULL;
				return &result;
			}
			if (PQntuples(resFr) > 0)
			{
				printf("status: %s\n", PQgetvalue(resFr, 0, 0));
				if (atoi(PQgetvalue(resFr, 0, 0)) > 0)
					u[i].isFriend = true;
				else
					u[i].isFriend = false;
			}
			else
				u[i].isFriend = false;
			printf("%d\t%s\t%d\n", u[i].id, u[i].nick, u[i].isFriend);
			PQclear(resFr);
		}
		result.users.users_len = PQntuples(res);
		result.users.users_val = u;
	}
    
    PQclear(res);
	PQfinish(conn);
	
	printf("finduser_3_svc called\n");
	return &result;
}

Result_getFriendshipRequests *
getfriendshiprequests_3_svc(Session *argp, struct svc_req *rqstp)
{
	static Result_getFriendshipRequests  result;
	result.status.descr = "";
	result.status.stat = true;
	result.users.users_val = NULL;
	result.users.users_len = 0;
	int userId = getUserId(argp->id);
	if (userId < 0)
	{
		printf("Error! Cannot get user id!\n");
		result.status.descr = "Error! Cannot get user id!";
		result.status.stat = false;
		result.users.users_val = NULL;
		return &result;
	}
	if (!updateActionTime(userId))
	{
		result.status.descr = "Error! Cannot update action time!";
		printf("Error! Cannot update action time!\n");
		result.status.stat = false;
		result.users.users_val = NULL;
		return &result;
	}
	
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
	const char * paramValues [1];
    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
		printf ("Connection to database failed: %s\n", PQerrorMessage(conn));
		exit_nicely(conn);
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.users.users_val = NULL;
        return &result;
    }
    paramValues[0] = itoa(userId);
    res = PQexecParams(conn, "SELECT target_user FROM roster WHERE tustatus = 0 AND rustatus = 0 AND roster_user = $1", 1, NULL, paramValues, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        PQclear(res);
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
        printf("Cannot get data from db for requests: %s\n", PQerrorMessage(conn));
		strcpy(errmsg, "Cannot get data from db for ger friendship requests:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.status.descr = errmsg;
		result.status.stat = false;
		result.users.users_val = NULL;
        return &result;
    }
	if(PQntuples(res) == 0)
	{
		printf("Cannot find new user requests.\n");
		result.status.descr = "";
		result.status.stat = true;
		result.users.users_val = NULL;
	}
	else
	{
		result.status.descr = "";
		result.status.stat = true;
		User * u = malloc(sizeof(User)*PQntuples(res));
		int i;
		for (i = 0; i < PQntuples(res); ++i)
		{
			paramValues[0] = PQgetvalue(res, i, 0);
			PGresult* resFr = PQexecParams(conn, "SELECT * FROM users WHERE id = $1", 1, NULL, paramValues, NULL, NULL, 0);
			if (PQresultStatus(resFr) != PGRES_TUPLES_OK)
			{
				PQclear(resFr);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Cannot get user for friendship requests from db: %s\n", PQerrorMessage(conn));
				strcpy(errmsg, "Cannot get user for friendship requests from db:\n");
				strcat(errmsg, PQerrorMessage(conn));
				result.status.descr = errmsg;
				result.status.stat = false;
				result.users.users_val = NULL;
				return &result;
			}
			if (PQntuples(resFr) > 0)
			{
				u[i].id = atoi(PQgetvalue(resFr, i, 0));
				u[i].name = PQgetvalue(resFr, i, 1);
				u[i].nick = PQgetvalue(resFr, i, 2);
				if (!strcmp(PQgetvalue(resFr, i, 4), "true"))
					u[i].onlineStatus = true;
				else
					u[i].onlineStatus = false;	
				u[i].isFriend = false;
			}
			else
			{
				PQclear(resFr);
				exit_nicely(conn);
				char* errmsg = malloc(sizeof(char)*500); 
				printf("Cannot cannot find user\n");
				strcpy(errmsg, "Cannot cannot find user");
				result.status.descr = errmsg;
				result.status.stat = false;
				result.users.users_val = NULL;
				return &result;
			}
			printf("%d\t%s\n", u[i].id, u[i].nick);
			PQclear(resFr);
		}
		result.users.users_len = PQntuples(res);
		result.users.users_val = u;
	}
	printf("getfriendshiprequests_3_svc called\n");
	return &result;
}

Status *
signup_3_svc(Args_register *argp, struct svc_req *rqstp)
{
	const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    conninfo = "dbname=echuraev";
    const char *paramValues[5];
    const char *paramCheckUnique[2];
    static Status result;

    conn = PQconnectdb(conninfo);

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Connection to database failed:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
		return &result;
    }
    
    paramCheckUnique[0] = argp->nick;
    paramCheckUnique[1] = argp->passwd;
    res = PQexecParams(conn, "SELECT * FROM users WHERE nick = $1 AND passwd = $2", 2, NULL, paramCheckUnique, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        PQclear(res);
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Cannot get data from db:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
		return &result;
    }
	
	if(PQntuples(res) > 0)
	{
		char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Error! User ");
		strcat(errmsg, argp->nick);
		strcat(errmsg, " already exist!");
		result.descr = errmsg;
		result.stat = false;
		return &result;
	}
	
	PQclear(res);
    
    paramValues[0] = argp->name;
    paramValues[1] = argp->nick;
    paramValues[2] = argp->passwd; /* Here should be some hash */
    paramValues[3] = "false";
    time_t current_time = time(NULL);
    struct tm * time_info;
    time_info = localtime(&current_time);
    char * buffer = malloc(sizeof(char)*80);
    strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", time_info);
    paramValues[4] = buffer;
    res = PQexecParams(conn, "INSERT INTO users (name, nick, passwd, onlinestatus, last_action) values($1, $2, $3, $4, $5)", 5, NULL, paramValues, NULL, NULL, 0);
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        PQclear(res);
        exit_nicely(conn);
        char* errmsg = malloc(sizeof(char)*500); 
		strcpy(errmsg, "Cannot add info to db:\n");
		strcat(errmsg, PQerrorMessage(conn));
		result.descr = errmsg;
		result.stat = false;
    }
    else
    {
    	result.descr = "";
		result.stat = true;
    }
	
    PQclear(res);

	PQfinish(conn);
	printf("signup_3_svc called\n");
	return &result;
}
